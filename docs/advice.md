# Some Naive Advice for Beginners 給硬件語言初學者的簡單建議

## Design 設計

### Always Preserve the Possibility of Modification 保留修改的空間

For some large module, say, the cache module, always use parameters when
coding, instead of just using the number you expect to use. You cannot
know whether the number is available in synthesis and implementation.

對於大模塊，如快取模塊，編寫代碼時應該使用參數，而不是直接使用你預期的數字。你無法知道在綜合和實現時，這個數字是否可用。

## Coding 編碼

### Always Blocks

- Never assigning a register in two always blocks;

  不要在兩個 always 模塊中對同一個寄存器賦值；
- Avoid assigning a register in a combinatorial block. This will infer latch
  in synthesis and is unstable.

  避免在組合模塊中對寄存器賦值。這會在綜合時推導出現鎖存器，造成不穩定且不符合預期的結果。

### Use Wires to Precalculate Information 使用綫預先計算信息

For some of the information that is used repeatedly, use wires to
reduce the number of wires in the design.

對於重複使用的信息，使用綫預先計算，以減少設計中的綫數。

## Simulation 模擬

### Use verilator instead of iverilog 使用 verilator 而非 iverilog

Verilator is able to check more problems than iverilog. Verilator is also
faster than iverilog.

Verilator 可以檢查出 iverilog 不能檢查出的問題。此外，Verilator 也比 iverilog 快。

## Synthesis & Implementation 綜合和實現

**Always check the warnings generated by Vivado! Search the message on the
Internet if you don't know what the warning means.**

**一定要檢查 Vivado 生成的警告！如果你不知道警告的意思，請在網上搜索。**

### FAQ 常見問題

#### Multi-driven net on pin Q with ...

This problem is caused by assigning a register in two always blocks.

這個問題是由於在兩個 always 模塊中對同一個寄存器賦值導致的。

#### Inferring lach for variable ...

This problem is caused by assigning a register in a combinatorial block.

這個問題是由於在組合模塊中對寄存器賦值導致的。必須將賦值操作放在 always 模塊中。
